
package gammadistribution;

/**
 * GammaDistribution
 * When alpah = k/2 and lamda = 0.5, the GammaDistribution will be a chi-square distribution
 * 
 * @author leo
 */
public class GammaDistribution {
    double alpha;
    double lambda;
    double X_MAX;//max x coordinate
    int size;//split(to simulate differential)
    Point2D[] points;
    
    public GammaDistribution(double alpha, double lambda,int size) throws IllegalArgumentException{
        if (alpha <= 0) {
            throw new IllegalArgumentException("alpha must be strictly positive.");
        }
        if (lambda <= 0) {
            throw new IllegalArgumentException("lambda must be strictly positive.");
        }
        this.alpha = alpha;
        this.lambda = lambda;
        this.size = size;
        this.points =new Point2D[size];
        
    }
    public Point2D[] getpoints(){
        return this.points;
    }
    /**
     * the points that is generated by gammadistribution
     * @param convergeThrd threshold of simulation converge to 0 
     */
    public void generateGammaDistribution(double convergeThrd){
        /**
         * find the converge point to decide which x_max should be used
         */
        this.X_MAX=convergeValue(convergeThrd);
        System.out.println("converge x: "+this.X_MAX);
        /**
         * [count must less than size]: prevent the arrayOutOfBound
         */
        int count = 0;//number of point equal to size
        for (double i = 0; i < X_MAX&&count<size; i += X_MAX / size) {//generate the distribution
            double probability = getProbability(i);
            points[count]=new Point2D(i, probability);
            count++;
        }
    }
    /**
     * find the converge point to decide which x_max should be used
     * @param convergeThrd threshold of simulation converge to 0 
     * @return 
     */
    private double convergeValue(double convergeThrd){
        
        /**
         * 
         * my old way:
         * The converge point should be the point that after the Vertext is passed.
         * In the other word, the converge point should be occured when the slope is negtive
         * 
         * while loop will stop when after the vertex is passed and the now value is under the converge threshold
         * 
         * my new way:
         * The converge point should appear after the mean x 
         * The mean of gammaDistribution is alpha/lambda
         * beacause the chi-square distribution will always converge to 0.0
         * so I use a very little value convergeThrd to set the threshold to decide when to stop ,then find the x
         * 
         */
        boolean unconverge=true;
        double x=getMean();
        double now=getProbability(x);
        double next=0;
        while(unconverge){
            if(now<=convergeThrd){
                unconverge=false;
            }
            x++;
            next=getProbability(x);
            now=next;
            
        }
        return x;
    }
    public double getProbability(double t){
        return gammaDistribution(alpha,lambda,t);
    }
    /**
     * 
     * @param alpha must > 0
     * @param lambda must > 0
     * @param t the X coordinate
     * @return gammaDistribution
     */
    private double gammaDistribution(double alpha, double lambda, double t) throws IllegalArgumentException {
        /**
         * too big alpha will let gammafunction too large(bigges alpha is 247/2)
         * 
         * SOLVE THE PROBLEM OF BIG ALPHA:
         * At large alpha(k/2,k is the degree of freedom or the random variable with iid and normal distribution), 
         * the chi-square distributions approximates the normal(gaussion) distribution
         * 
         * chi-square distribution:
         * mean=alpha/lambda --> (k/2)/0.5 ---> k
         * variance=alpha/lambda^2 --> mean/lambda ----when lambda equal to 0.5--> 2*mean -->2*k
         * 
         * 
         */
        if(alpha>247.0/2){
            return normal_distribution(getMean(),getVariance(),t);
            //throw new IllegalArgumentException("alpha is too big ,alpha should smaller than 247.0/2");
        }
        if (alpha <= 0) {
            throw new IllegalArgumentException("alpha must be strictly positive.");
        }
        if (lambda <= 0) {
            throw new IllegalArgumentException("lambda must be strictly positive.");
        }
        
        double gammafunction=gammaFunction(alpha);
        double gamma = (Math.pow(lambda, alpha) / gammafunction) * Math.pow(t, alpha - 1) * Math.exp(-lambda * t);
        return gamma;
    }
    /**
     *
     * @param alpha ex:2 or 2.5 must > 0
     * @throws IllegalArgumentException if {@code alpha <=0}
     * @return gamma
     */
    private double gammaFunction(double alpha) throws IllegalArgumentException{
        if (alpha <= 0) {
            throw new IllegalArgumentException("alpha must be strictly positive.");
        }
        double gamma;
        /**
         * This is a special calculate for gamma function when alpha is a real number
         *           a 
         * gamma = ----- * pi ^ 0.5
         *          2^b
         *          (c)
         *
         */
        if(alpha==0.5){//when alpha==0.5 
            return Math.pow(Math.PI, 0.5);
        }else if (alpha + 0.5 == Math.round(alpha)) {
            gamma = 0;
            int n = (int) (alpha * 2);//the biggest odd number
            double a = 1;
            int count = 0;
            for (int i = 1; i < n; i = i + 2) {//sum of all odd number that smaller than the biggest odd number n
                a *= i;
                count++;//the number of odd number that smaller than the biggest odd number n
            }
            double b = count;
            double c = a / Math.pow(2, b);
            gamma = c * Math.pow(Math.PI, 0.5);
        } else {
            /**
             * this is the general calculate for gamma function when alpha is an
             * integer
             *
             * n factorial
             */
            gamma = 1;
            for (int i = 1; i <= alpha - 1; i++) {
                gamma *= i;
            }

        }
        return gamma;
    }
    public double getMean(){//0.5
        return alpha/lambda;
    }
    public double getVariance(){
        return alpha/Math.pow(lambda,2);
    }

    public double normal_distribution(double mean, double variance,double t) {
        return (1.0/Math.pow(2*Math.PI*variance, 0.5))* Math.exp(-(Math.pow(t-mean,2))/(2*variance));
    }


}
